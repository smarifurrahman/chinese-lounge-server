[
    {
        "id": 1,
        "question": "Differences between uncontrolled and controlled components.",
        "answer": "In React, controlled and uncontrolled components have specific meanings and refer to two different ways of managing the state of form components such as inputs, checkboxes, and radio buttons. A controlled component is a component that is fully controlled by its parent component, meaning that the parent component manages the state of the child component. In a controlled component, the parent component sets the value of the input element and responds to any changes in the input by updating its own state. This approach requires more code and a higher degree of coupling between components, but it ensures that the component's behavior is predictable and that the component always reflects the current state of the parent. An uncontrolled component, on the other hand, is a component that manages its own state internally, without any direct involvement from the parent component. In an uncontrolled component, the component sets its own initial value and responds to user input by updating its internal state. This approach requires less code and is less tightly coupled, but it can lead to unpredictable behavior if the component's state becomes out of sync with the parent component."
    },
    {
        "id": 2,
        "question": "How to validate React props using PropTypes?",
        "answer": "React provides a built-in utility called PropTypes for validating the props passed to a component. PropTypes allows us to specify the expected data type of a prop, as well as whether it is required or not. To use PropTypes, we'll first need to import it from the 'prop-types' package. Then, we can define the PropTypes for our component by adding a propTypes object to the component. Here are some other examples of how you can use PropTypes: MyComponent.propTypes = { numberProp: PropTypes.number, stringProp: PropTypes.string.isRequired, boolProp: PropTypes.bool, funcProp: PropTypes.func, arrayProp: PropTypes.array, objectProp: PropTypes.object, anyProp: PropTypes.any };"
    },
    {
        "id": 3,
        "question": "Difference between nodejs and express js.",
        "answer": "Node.js and Express.js are two popular technologies used in building web applications in JavaScript. Node.js is a server-side JavaScript runtime that allows developers to run JavaScript code on the server. It is built on top of the V8 JavaScript engine used in Google Chrome, and provides an event-driven, non-blocking I/O model that makes it highly scalable and efficient for building network applications. Express.js, on the other hand, is a web application framework built on top of Node.js. It provides a set of tools and features that make it easier to build web applications and APIs. Express.js provides a set of middleware functions that can be used to handle requests, parse data, and perform various other tasks. It also provides a routing system that allows developers to define endpoints and handle HTTP requests. Here are some key differences between Node.js and Express.js: Node.js is a JavaScript runtime, while Express.js is a web application framework built on top of Node.js. Node.js provides a core set of APIs for building network applications, while Express.js provides a set of tools and features for building web applications. Node.js provides low-level APIs for handling requests and responses, while Express.js provides a higher-level API that simplifies the process of handling requests and building web applications. Node.js can be used to build a wide range of applications, including web applications, mobile applications, desktop applications, and more, while Express.js is primarily focused on building web applications and APIs."
    },
    {
        "id": 4,
        "question": "What is a custom hook, and why will you create a custom hook?",
        "answer": "A custom hook is a reusable function in React that encapsulates stateful logic and can be used in functional components. Custom hooks are created using the naming convention of starting with the word 'use' followed by a descriptive name. Custom hooks allow us to abstract complex logic, such as handling API requests, managing local state, or handling side effects, into reusable functions that can be easily shared and reused across multiple components. By using custom hooks, we can promote code reusability, maintainability, and separation of concerns, as we can encapsulate component-specific logic in custom hooks and use them in multiple components without repeating the same logic in each component. We might create a custom hook when we have a piece of stateful logic that is being used in multiple components. Custom hooks allow us to encapsulate that logic in a reusable function that can be used across our application."
    }
]